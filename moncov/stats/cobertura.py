#!/usr/bin/pytho
import ast
import collections
import sys


import pymongo
import time

#to generate xml
from lxml import etree
from lxml.builder import E
from lxml.builder import ElementMaker


# *_[EX] events: Enter eXit
M_E = 'M_E' # Module
M_X = 'M_X'
F_E = 'F_E' # Function
F_X = 'F_X'
C_E = 'C_E' # Class
C_X = 'C_X'
O_E = 'O_E' # Other
O_X = 'O_X'


BTT = 'BTT'   # stack bottom
CTT = 'CTT'  # bottom of regular class
FTT = 'FTT'  # bottom of regular method/function

# stack actions
NOOP = lambda: lambda stack: stack
PUSH = lambda items: lambda stack: stack + items

#filename = None

# Transition table for cobertura.dtd
TBL = {
        (M_E, BTT): PUSH([BTT]),
        (M_X, BTT): PUSH([BTT]),

        (F_E, BTT): PUSH([BTT, F_E]), # module-level function
        (F_E, CTT): PUSH([CTT, FTT]), # method
        (F_E, FTT): PUSH([FTT, F_E]), # function within method
        (F_E, F_E): PUSH([F_E, F_E]), # function within function
        (F_E, C_E): PUSH([C_E, F_E]), # function within nested class
        (F_E, O_E): PUSH([O_E, F_E]), # function within other statement
        (F_X, FTT): NOOP(),           # leaving method
        (F_X, F_E): NOOP(),           # leaving any nested function

        (C_E, BTT): PUSH([BTT, CTT]), # entering regular class
        (C_E, CTT): PUSH([CTT, C_E]), # entering class nested in regular class
        (C_E, FTT): PUSH([FTT, C_E]), # entering class within a method
        (C_E, C_E): PUSH([C_E, C_E]), # entering class within a class
        (C_E, F_E): PUSH([F_E, C_E]), # entering class within a function
        (C_E, O_E): PUSH([O_E, C_E]), # entering class within other statement
        (C_X, CTT): NOOP(),           # leaving regular class
        (C_X, C_E): NOOP(),           # leaving any nested function

        (O_E, BTT): PUSH([BTT, O_E]), # entering other module-level statement
        (O_E, FTT): PUSH([FTT, O_E]), # entering other method-level statement
        (O_E, CTT): PUSH([CTT, O_E]), # entering other regular-class-level statement
        (O_E, F_E): PUSH([F_E, O_E]), # entering other (nested-)function-level statement
        (O_E, C_E): PUSH([C_E, O_E]), # entering other nested-class-level statement
        (O_E, O_E): PUSH([O_E, O_E]), # entering other (nested) statemetn
        (O_X, O_E): NOOP(),            # leaving other (nested) statement
        (O_X, FTT): PUSH([FTT]),
        (O_X, CTT): PUSH([CTT]),
        (O_X, BTT): PUSH([BTT]),
}



#get data from mongo

#create xml skeleton
E = ElementMaker()
xml = (
    E.coverage(
        E.packages(
            )
        )
    )

xml_tree = etree.ElementTree(xml)
xml.insert(0, etree.Comment("Generated by pushdown_moncov.py: http://github.com/bla-bla-bla"))
 #later overwritten with data from mongodb for every filename, stores touched lines
taken_lines = [] #a variable to keep a list of unique lines of all called lines



class PushDownAutomaton(object):

    # by default, use `lambda event, stack_event: None' callbacks for any event
    def __init__(self, stack=None, callbacks=collections.defaultdict(lambda: lambda event, stack_event: None)):
        if stack is None:
            stack = [BTT]
        self.reset(stack)
        self.callbacks = callbacks

    def reset(self, stack=None):
        if stack is None:
            stack = [BTT]
        self.stack = stack

    def __repr__(self):
        return type(self).__name__ + '(stack=%r)'% self.stack

    def __call__(self, event):
        stack_event = self.stack.pop()
        # perform callback
        self.callbacks[(event, stack_event)](event, stack_event)
        # perform stack manipulation based on the transition table
        self.stack = TBL[(event, stack_event)](self.stack)
        #import pprint
        #print pprint.pformat(self.stack), event


class Line(object):
    prefix = ""
    def __init__(self, node):
        self.node = node

    def __repr__(self):
        return type(self).__name__ + "(%r)" % self.node
        #print self

    def __str__(self):
        return self.prefix + type(self).__name__ + ": %s" % self.node.lineno

    def __call__(self, node):
        '''print line in case node linenos differ; update self.node'''
        if not hasattr(self.node, "lineno"):
            lineno = 0
        else:
            lineno = self.node.lineno
        if not hasattr(node, "lineno"):
            return
        if lineno != node.lineno:
           # new line
           self.node = node
           #print self

class ModuleLine(Line):
    prefix = " "


class ClassLine(Line):
    prefix = "   "

class MethodLine(Line):
    prefix = "    "

    #print etree.tostring(xml_tree, pretty_print=True )


class LineStatus(object):
    def __init__(self):
        self.set_stack = []

    @property
    def top_set(self):
        #print self.set_stack[-1]
        return self.set_stack[-1]

    @top_set.setter
    def top_set(self, other):
        self.set_stack[-1] = other

    def push_set(self):
        self.set_stack.append(set())

    def pop_set(self):
        return self.set_stack.pop()

    def add_line(self, lineno):
        #print lineno
        self.top_set.add(lineno)

class Visitor(ast.NodeVisitor):

    def __init__(self, *args, **kvs):
        callbacks = {
            (M_E, BTT): self.init_module,
            (M_X, BTT): self.exit_module,
            (C_E, BTT): self.init_class,
            (F_E, CTT): self.init_method,
            (C_X, CTT): self.exit_class,
            (F_X, FTT): self.exit_method,
        }
        self.callbacks = collections.defaultdict( \
            lambda: self.line_handler,
            callbacks.items()
        )
        self.node = None
        self.line = None
        self.filename = kvs.pop('filename', None)
        self.hits_list = kvs.pop('hits_list', None)


        self.status = xml[-1]               #current xml node
        self.methods_hits_counter = 0
        self.class_hits_counter = 0
        self.package_hits_counter = 0
        self.total_methods_lines = 0
        self.total_package_lines = 0

        self.pda = PushDownAutomaton(callbacks=self.callbacks)
        self.line_status = LineStatus()
        super(Visitor, self).__init__(*args, **kvs)

    def visit_Module(self, node):
        self.generic_visit(node, (M_E, M_X))

    def visit_FunctionDef(self, node):
        self.generic_visit(node, (F_E, F_X))

    def visit_ClassDef(self, node):
        self.generic_visit(node, (C_E, C_X))

    def generic_visit(self, node, events=(O_E, O_X)):
        self.node = node
        self.pda(events[0])
        super(Visitor, self).generic_visit(node)
        self.pda(events[1])

    def line_handler(self, event, stack_event):
        self.line(self.node)
        if hasattr(self.node, 'lineno'):
            self.line_status.add_line(self.node.lineno)

            #{to generate xml}
            if self.node.lineno not in taken_lines:

                if self.node.lineno in self.hits_list:
                    #counter of hits for package/class/method lines
                    line_hits = 1
                    self.hits_list.remove(self.node.lineno)

                    if self.status.tag == 'lines':
                        self.methods_hits_counter += 1
                        self.class_hits_counter += 1
                        self.package_hits_counter += 1
                    if self.status.tag == 'package':
                        self.package_hits_counter +=1

                else:
                    line_hits = 0

                if self.status.tag != "package":
                    self.status.append(E(tag = 'line', hits = str(line_hits), number = str(self.node.lineno)))

                taken_lines.append(self.node.lineno)
             #{/to generate xml}


    def init_module(self, event, stack_event):
        #print "Module:"

        #xml[-1].append(E(tag = "package"))
        self.status.append(E(tag = "package"))

        self.status = xml[-1]

        self.package_hits_counter = 0
        self.total_package_lines = 0
        self.line = ModuleLine(self.node)

        self.status = xml[-1][-1]

        #xml[-1][-1].append(E(tag = "classes"))
        self.status.append(E(tag = "classes"))


        self.line_status.push_set()



    def exit_module(self, event, stack_event):
        line_set = self.line_status.pop_set()
        #print "...total module lines: %s" % len(line_set)
        self.line(self.node)

        self.status = xml[-1][-1]
        self.status.set('name', self.filename)

        if self.total_package_lines != 0:
            package_line_rate = str(float(self.package_hits_counter)/self.total_package_lines)
        else:
            #print "Module zero division!", filename, self.total_package_lines
            package_line_rate = '0'


        self.status.set('line-rate', package_line_rate)
        self.status.set('branch-rate', '1.0')
        self.status.set('complexity', '1.0')


    def init_class(self, event, stack_event):
        #print " Class: %s" % self.node.lineno
        self.status = xml[-1][-1][-1]
        #xml[-1][-1][-1].append(E(tag = "class"))
        self.status.append(E(tag = "class"))
        self.status = xml[-1][-1][-1][-1]
        #xml[-1][-1][-1][-1].append(E(tag = "methods"))
        #xml[-1][-1][-1][-1].append(E(tag = "lines"))

        self.line_status.push_set()
        self.class_hits_counter = 0
        #self.total_methods_line_set = []
        #print self.status.tag
        self.line = ClassLine(self.node)


        self.status.append(E(tag = "methods"))
        self.status.append(E(tag = "lines"))
        self.status = xml[-1][-1][-1][-1][-1]


    def exit_class(self, event, stack_event):
        self.status = xml[-1][-1][-1]
        line_set = self.line_status.pop_set()
        #print " ...total class lines: %s" % len(line_set)
        #xml[-1][-1][-1][-1].set('totalInClass', str(len(line_set))) #total
        #print 'self.hits_counter', self.hits_counter

        xml[-1][-1][-1][-1].set('name', 'default')
        xml[-1][-1][-1][-1].set('filename', self.filename)

        if len(line_set) != 0 and self.total_methods_lines != 0:
            class_line_rate = str(float(self.class_hits_counter)/(len(line_set)+self.total_methods_lines))
        elif len(line_set) == 0 and self.total_methods_lines != 0:
            class_line_rate = str(float(self.class_hits_counter)/self.total_methods_lines)
        elif len(line_set) != 0 and self.total_methods_lines == 0:
            class_line_rate = str(float(self.class_hits_counter)/len(line_set))
        else:
            print "Class zero division!", self.filename, len(line_set)
            class_line_rate = '0'

        xml[-1][-1][-1][-1].set ('line-rate', class_line_rate)
        xml[-1][-1][-1][-1].set('branch-rate', '1.0')
        xml[-1][-1][-1][-1].set('complexity', '1.0')

        self.line = ModuleLine(self.node)

    def init_method(self, event, stack_event):
        #print "  Method: %s" % self.node.lineno
        self.status = xml[-1][-1][-1][-1][0]
        #xml[-1][-1][-1][-1][0].append(E(tag = "method"))
        self.status.append(E(tag = "method", name = self.node.name))
        self.status = xml[-1][-1][-1][-1][0][-1]

        self.status.append(E(tag = "lines"))
        #xml[-1][-1][-1][-1][0][-1].append(E(tag = "method_lines"))

        self.status = xml[-1][-1][-1][-1][0][-1][-1] # new
        self.line_status.push_set()
        self.lines = 0
        self.methods_hits_counter = 0
        self.line = MethodLine(self.node)





    def exit_method(self, event, stack_event):
        self.status = xml[-1][-1][-1][-1][-1]
        line_set = self.line_status.pop_set()
        #print "  ...total method lines: %s" % len(line_set)
        #xml[-1][-1][-1][-1][0][-1].set('totalInMethod', str(len(line_set))) #total

        xml[-1][-1][-1][-1][0][-1].set('signature', 'default')

        self.total_methods_lines += len (line_set)
        if len(line_set) != 0:
            method_line_rate = str(float(self.methods_hits_counter)/len(line_set))
        else:
            #print "Method zero division!", filename, len(line_set)
            method_line_rate = '0'

        xml[-1][-1][-1][-1][0][-1].set ('line-rate', method_line_rate)

        xml[-1][-1][-1][-1][0][-1].set('branch-rate', '1.0')


        self.line = ClassLine(self.node)


###

def generate_xml(dbhost = "localhost", dbport = 27017, dbname = 'moncov', output='moncov.xml'):

    connection=pymongo.connection.Connection(dbhost, dbport)
    db=pymongo.database.Database(connection, dbname)
    cursor=list(db.lines.find())
    cursor_grouped = db.lines.aggregate([{"$group": {"_id": "$_id.file",
        "lines": {"$addToSet": "$_id.line"}}}])



    for doc in cursor_grouped['result']:
        if str(doc['_id']).startswith('<'):
            continue
            #if doc['_id']=='/usr/lib/python2.7/site-packages/web/form.py':
            #print doc
        try:
            with open(str(doc['_id'])) as fd:
                hits_list = sorted(doc['lines'])
                filename = str(doc['_id'])
                src = fd.read()
                print "Opened file: %s" % str(doc['_id'])

            tree = ast.parse(src)
            #print src
            # import astpp
            #print astpp.dump(tree, annotate_fields=True, include_attributes=True)
            visitor = Visitor(filename=filename, hits_list = hits_list)
            #visitor.filename = f
            #print ast.dump(tree)
            visitor.visit(tree)

        except IOError as e:
            print "Can't read: %s" % e.message, str(doc['_id'])
            #sys.exit(2)
            continue

    f = open(output, 'w')
    f.write(etree.tostring(xml_tree, pretty_print=True, xml_declaration=True, doctype="<!--DOCTYPE coverage SYSTEM 'http://cobertura.sourceforge.net/xml/coverage-04.dtd'-->"))
    f.close()

if __name__ == "__main__":
    start_time = time.time()
    generate_xml()
    finish_time = time.time()
    run_time = finish_time - start_time
    print run_time

